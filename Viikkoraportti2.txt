Toisen viikon aikana minulle selvisi, miten lineaarisesti skaalautuva RegEx-tulkki pitää käytännössä toteuttaa. Tällöin aiempi rekursiivinen toteutukseni ei ollut enää mahdollinen, sillä rekursion turhien haarojen tunnistaminen on mahdotonta ja haarojen määrä skaalautuu eksponentiaalisesti.

Sen sijaan algoritmin voi toteuttaa lineaarisessa ajassa sen ansiosta, että tilakoneella ei ole muistia eli kulloiseenkin tilaan saavuttaessa aiemmalla polulla ei ole väliä. Tällöin tilojen määrä pysyy vakiona algoritmin edetessä. Tämä vaatii koodin toteuttamisen Thompsonin tapaan yksi askel kerrallaan, jolloin tilakone on useassa tilassa samalla askeleella. Näiden tilojen tallentamiseen käytin hajautustaulukkoon perustuvaa joukkoa NSMutableSet.

Ongelmaksi lineaarisessa toteutuksessa kuitenkin osoittautuu menneiden matchien muistaminen. Koska määritelmällisesti tilakoneella ei ole muistia, mutta määrittelydokumentin mukaisesti regexpistä halutaan ulos myös matchin aloitusindeksi stringissä, dokumentissa on tavallaan kaksi keskenään ristiriitaista toteutusvaatimusta. Eksponentiaalisessa ratkaisussa jokainen haara etenee erikseen ja matchin aloituskohdan muistaminen on triviaalia; lineaarisessa ratkaisussa matchien aloituskohdat tulee tallentaa johonkin erilliseen rakenteeseen, joka pitää kirjaa siitä, missä haarassa tunnistus alkoi minkäkin kirjaimen kohdalla.

Päätin toteuttaa tämän samalla tavalla kuin Thompsonin tekemä Googlen algoritmi käytännössä, eli vaatimalla kullakin kierroksella matcheilta tiettyä suoritusjärjestystä. Tämä takaa sen, että lopputuloksena saadaan ennustettavasti greedy tai thrifty matchi; oletusarvoisesti regex-standardina on matchata mahdollisimman pitkään stringiin silloin, kun useampia submatcheja on tarjolla.

Kevyin keksimäni toteutus tälle käytännölle on lisätä ROState-olioon kaksi kokonaislukua, johon tilakone joka kierroksella tallentaa haaraa vastaavan matchin aloitusindeksin seuraavaa kierrosta varten. Toteutuksen toimivuus edellyttää kuitenkin myös sitä, että tilat käydään läpi laskevassa match-järjestyksessä, 

Suorituskykytestausta en ole vielä lähelläkään, sillä koko viikko on mennyt hyvin tiiviisti paralleelin tilakoneen toteutuksessa ja sen verifioinnissa; mitään regex-operaatioita ei ole vielä toteutettu, tässä vaiheessa algoritmi matchaa ainoastaan stringejä.