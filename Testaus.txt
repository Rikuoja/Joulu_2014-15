Testaus jakautuu kahteen osaan: itse äärellisen automaatin yksittäisten matchien toimivuuden testaamiseen ja toisaalta regexp-matchauksen testaamiseen tilanteissa, joissa syötettävä stringi sisältää mahdollisesti useita peräkkäisiä matcheja.

Useamman matchauksen tilanteessa matchauksen lähtökohtana on, kuten yleensäkin säännöllisissä lausekkeissa, että yksi osa stringiä voi osua vain yhteen matchiin. Näin ollen ensimmäisen matchin löydyttyä matchausta jatketaan tämän jälkeisestä merkistä eteenpäin. Tällaisia toistuvia peräkkäisiä matcheja sisältävien stringien testaaminen on hyvin suoraviivaista. Näihin tarvittavat testit on sisällytetty luokkaan RORegExTest.

Yksittäisen matchauksen testaaminen on vaikein osa testausta, sillä äärellisillä määrillä testejä ei voida vielä aukottomasti vakuuttua siitä, että ohjelmalogiikka toimii kaikissa tilanteissa oikein. Varmempi testaus vaatisi järjestelmällistä loogista analyysia siitä, mihin tiloihin ohjelma voi minkäkinlaisilla stringeillä päätyä. Automaatti on toki toteutettu analysoimalla kynällä ja paperilla, mitkä tilat ovat mahdollisia ja miten ne tulee toteuttaa niin, että tulos on aina oikea, mutta en edelleenkään voi olla vakuuttunut siitä, että analyysini on oikea kaikissa tilanteissa.

Yksittäistä regex-matchia kuvaavat testit ovat luokassa RONFAtest. Lähdin kehitystyössä liikkeelle siitä, että toteutin mielivaltaisten stringien matchaamisen ensimmäisenä yksittäisistä kirjaimista lähtien. Käytännössä kaikkien mahdollisten stringien matchaaminen oikealla tavalla edellyttää jo kokonaista epädeterminististä tilakonetta, joten aikaa tilakoneen konstruointiin ja ennen kaikkea matchatun stringin pituuden selvittämiseen meni nimenomaan tässä vaiheessa runsaasti.

Stringien testaamisen jälkeen luokka RONFAtest sisältää haluttujen operaattorien testauksen. Operaattoreita käytettäessä tulee testata myös sulkulausekkeiden toimivuus eli koodin rekursio-ominaisuus sisäkkäisten sulkeiden tapauksessa. Lisää operaattoreita on yllättävän helppoa ja nopeaa lisätä sekä testeihin että RONFA-luokkaan, kun itse tilakoneen toteutus on valmis. Toistaiseksi testit on implementoitu operaattoreille . (mikä tahansa kirjain), * (mikä tahansa määrä kirjaimia), | (inklusiivinen OR) sekä kirjain? (valinnainen kirjain).

Näillä operaattoreilla voidaan tehdä myös suorituskykytestausta, joka on olennaisin osa testausta, kun tavoitteena on ollut lineaarisesti skaalautuva algoritmi. Lineaarisen skaalautuvuuden testaus on syytä tehdä lausekkeella, joka tuottaa ongelmia backtrackaus-algoritmeille eksponentiaalisesti kasvavan vaativuuden vuoksi. Tällainen lauseke on Coxin mallin mukaan (a?)^n(a)^n eli lauseke, jossa on n kappaletta valinnaista a-kirjainta sekä tämän jälkeen n kappaletta välttämättömiä a-kirjaimia. Mikäli tämä lauseke halutaan matchata stringiin, jossa on täsmälleen n a-kirjainta, eksponentiaalisesti kasvavalle algoritmille ongelmia tulee melko nopeasti; algoritmi käy läpi kaikki mahdollisuudet, joissa valinnaiset a-kirjaimet voivat olla mukana stringissä, ja näiden mahdollisuuksien määrä skaalautuu eksponentiaalisesti.

Lineaarisesti stringin alusta loppuun etenevä algoritmi sen sijaan haarautuu m:nnellä askeleella korkeintaan (ja tämän lausekkeen tapauksessa täsmälleen!) m:ään osaan, sillä m:n pituinen lauseke synnyttää aina tilakoneen, jossa on korkeintaan m kappaletta erilaisia tiloja. Lisätyötä aiheuttaa se, että käyttämässäni matchauksen alkupisteen tallennusmenetelmässä ennen matchausta kaikki tilat tulee käydä läpi ja nollata aloitusindeksit, eli käytännössä rakentaa tilakone uudestaan jokaista matchia varten. Tämä operaatio vaatii O(m^2)-ajan, sillä jokaisella askeleella tilakone saattaa luoda korkeintaan yhden uuden tilan. Itse matchauksessa jokainen askel vaatii O(m)-ajan, joten n:n pituisen stringin matchaus vaatii ajan O(mn) tai koneen konstruointi mukaan lukien O(m(m+n))-ajan.

Lausekkeen (a?)^n(a)^n matchauksen skaalautuvuus on osoitettu testeillä testPerformancePathologicaln, missä stringin pituus on n=20,40,60,80. Tällöin itse regexin pituudeksi tulee 3n. Koko findMatch-metodin suoritus tulisi kestää ajan O(3n(3n+n)) eli O(n^2). Tulosten perusteella skaalautuminen on hieman huonompaa kuin neliöllinen, mutta merkittävästi parempaa kuin mitä esimerkiksi kuutiollinen skaalautuminen aiheuttaisi.